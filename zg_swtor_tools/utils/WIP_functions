import bpy
import bmesh

# ------------------------------------------------------------------------------------------------

def separate_by_specific_materials(obj_or_obj_name, materials_names, separate = True):

    """
    Separates an object's polys associated to specified materials
    into separate objects per those materials. By default it
    deletes those polys and materials from the original object.
    
    Args:
        obj_or_obj_name (bpy.types.object or string): object to be separated.
        materials_names (list): list of materials names.
        separate (bool, optional): If False, no separate objects are produced and the polys are just deleted.
    Returns:
        list of bpy.types.object: list of separated objects, empty if there were no materials matches.
    """

    if type(obj_or_obj_name) == str:
        original_obj = bpy.data.objects[obj_or_obj_name]
    else:
        original_obj = obj_or_obj_name
        
    original_mesh = original_obj.data
    new_objs = []
    
    # Get material indices to separate
    mat_indices = [i for i, mat in enumerate(original_mesh.materials) if mat.name in materials_names]
    
    if separate:
        for mat_index in mat_indices:
            # Create a duplicate object
            new_obj = original_obj.copy()
            new_obj.data = original_obj.data.copy()
            bpy.context.collection.objects.link(new_obj)
            new_obj.name = f"{original_obj.name}_{original_mesh.materials[mat_index].name}"
            
            # Create a new bmesh to work with
            bm = bmesh.new()
            bm.from_mesh(new_obj.data)
            
            # Iterate through all faces and hide those that don't use the current material
            faces_to_delete = [f for f in bm.faces if f.material_index != mat_index]
            bmesh.ops.delete(bm, geom=faces_to_delete, context='FACES')
            
            # Update the mesh
            bm.to_mesh(new_obj.data)
            bm.free()
            
            new_objs.append(new_obj)
    
    # Update original object to remove specified materials' polys
    bm = bmesh.new()
    bm.from_mesh(original_mesh)
    faces_to_delete = [f for f in bm.faces if f.material_index in mat_indices]
    bmesh.ops.delete(bm, geom=faces_to_delete, context='FACES')
    bm.to_mesh(original_mesh)
    bm.free()

    # Update original object to remove specified materials' material slots
    for i, slot in enumerate(original_obj.material_slots[:]):  # Use a copy of the list to modify the original safely
        if slot.material and slot.material.name in materials_names:
            # Remove the material slot by removing the object.data.materials' element (by index)
            original_obj.data.materials.pop(index=i)

    return new_objs



# ------------------------------------------------------------------------------------------------



def replace_with_empty(obj):
    """
    ChatGPT-generated code (like pulling teeth).
    Preserves the object's original name (and its parent and children relationships.

    Args:
        obj (bpy.types.Object): object to be replaced.

    Returns:
        obj (bpy.types.Object): replacement Empty object.
    """    

    # No checks to force exception if wrongly fed.
    # if obj is None:
    #     print("Object is None. Exiting.")
    #     return
    
    
    # Save the object's name and world transformation matrix
    obj_name = obj.name
    obj_matrix_world = obj.matrix_world.copy()
    
    # Save the parent
    parent = obj.parent
    
    # Save the children and their world matrices
    children = [(child, child.matrix_world.copy()) for child in obj.children]
    
    
    # Create a new empty object
    empty = bpy.data.objects.new(f"{obj.name}_empty", None)
    bpy.context.collection.objects.link(empty)
    
    # Set the empty's world transformation to match the original object
    empty.matrix_world = obj_matrix_world
    
    # Set the parent of the empty to be the same as the original object's parent
    if parent is not None:
        empty.parent = parent
        empty.matrix_parent_inverse = obj.matrix_parent_inverse
    
    # Re-parent the children to the empty and restore their world transformations
    for child, world_matrix in children:
        child.parent = empty
        child.matrix_world = world_matrix
    
    # Optionally, transfer custom properties, constraints, etc. from the original object to the empty
    for prop in obj.keys():
        if prop not in "_RNA_UI":
            empty[prop] = obj[prop]
    
    # Store the object's name
    obj_name = obj.name
    
    # Delete the original object
    bpy.data.objects.remove(obj)

    # Make sure empty's name is correct after original object
    # is no more and its name has been freed, to avoid .001s
    # (BF intends to make collisions control stricter in the future).
    empty.name = obj_name

    return empty



# ------------------------------------------------------------------------------------------------


@contextlib.contextmanager
def suppress_stdout(suppress=True):
    # Console output supressor for hiding the .gr2 addon's output.
    # Use suppress=False to allow for specific outputs
    # in the middle of a suppressed block of code.
    # Usage is:
    # with suppress_stdout():
    #     <code to be suppressed here>
    #     Use suppress=False to allow for specific outputs
    #     in the middle of a suppressed block of code.

    # (No need to explicitly stop suppression).
    if suppress:
        with io.StringIO() as buffer:
            old_stdout = sys.stdout
            sys.stdout = buffer
            try:
                yield
            finally:
                sys.stdout = old_stdout
    else:
        yield


# Create objects-fitting Empties (not in use yet)
def encase_objects_with_empty(objects, empty_name = "Empty", collection_name = ""):
    # Create a new Empty object
    empty = bpy.data.objects.new(empty_name, None)
    if collection_name == "":
        bpy.context.collection.objects.link(empty)
    else:
        if collection_name not in bpy.data.collections:
            bpy.data.collections.new(collection_name)
        bpy.data.collections[collection_name].objects.link(empty)
        
    # Set the Empty object's display type to 'CUBE'
    empty.empty_display_type = 'CUBE'

    # Set the Empty object's origin to the center of its base
    empty.matrix_world = calculate_base_center_matrix(objects)

    # Parent objects to the Empty object
    for obj in objects:
        obj.parent = empty
        
    return empty
    
def calculate_base_center_matrix(objects):
    # Find the minimum and maximum coordinates of all objects' bounding boxes
    min_x, min_y, min_z = float('inf'), float('inf'), float('inf')
    max_x, max_y, max_z = float('-inf'), float('-inf'), float('-inf')

    for obj in objects:
        bbox = obj.bound_box
        for vertex in bbox:
            min_x = min(min_x, vertex[0])
            min_y = min(min_y, vertex[1])
            min_z = min(min_z, vertex[2])
            max_x = max(max_x, vertex[0])
            max_y = max(max_y, vertex[1])
            max_z = max(max_z, vertex[2])

    # Calculate the center of the base
    base_center = (
        (min_x + max_x) / 2,
        (min_y + max_y) / 2,
        min_z
    )

    # Calculate the translation vector to move the origin
    translation_vector = -base_center

    # Create a translation matrix
    translation_matrix = Matrix.Translation(translation_vector)

    return translation_matrix



# THIS IS PROBABLY NOT WORKING
def iterate_collections(collection, function):
    # (its only use in this operator is passing it
    # exclude_collection_lights, which excludes
    # the collection from the view_layer, but that
    # fn is known not to be working)
    #
    # Define a function to recursively iterate over
    # all collections in a hierarchy and apply
    # a function to them.

    function(collection)
    
    # Recursively iterate over all child collections
    for child_collection in collection.children:
        iterate_collections(child_collection, function)

def exclude_collection_lights(collection):
    # DOESN'T WORK (collections don't
    # have an .exclude method)
    if " - Lights" in collection.name:
        collection.exclude = True
        

def hide_collection_children(collection):
    for child in collection.children:
        child.hide_viewport = True

def link_objects_to_collection (objects, collection, move = False):
    """
    Links objects to a Collection. If move == True,
    it unlinks the objects from their current Collections first.
    Accepts a single object or a list of objects. 
    """

    # Make sure objects works as a list for the loop.
    if not isinstance(objects, list):
        objects = [objects]

    for object in objects:
        # First, unlink from any collections it is in.
        if object.users_collection and move == True:
            for current_collections in object.users_collection:
                current_collections.objects.unlink(object)

        # Then link to collection.
        collection.objects.link(object)

    return


def parent_with_transformations(obj_to_parent, parent_obj, inherit_transformations=True):
    """
    Parents an object to another, inheriting its transformations
    (plain .parent method-style) or not (imitating bpy.ops).
    Args:
        obj_to_parent (_type_): bpy.data.object.
        parent_obj (_type_): bpy.data.object.
        inherit_transformations (bool, optional): defaults to True.
    """
    # Clear any existing parent-child relationship
    obj_to_parent.parent = None
    
    # Set new parent-child relationship
    obj_to_parent.parent = parent_obj
    
    # Inherit transformations
    if inherit_transformations:
        # Get parent's world matrix
        parent_matrix = parent_obj.matrix_world
        
        # Apply parent's world matrix to child's local matrix
        obj_to_parent.matrix_local = parent_matrix @ obj_to_parent.matrix_local
    
    # Clear child's transformation if not inheriting transformations
    else:
        obj_to_parent.location = (0,0,0)
        obj_to_parent.rotation_euler = (0,0,0)
        obj_to_parent.scale = (1,1,1)

    return


def find_closest_match(strings_list, reference_string):
    
    # Finds the closest match to a reference string
    # among the strings in a list.
    # Meant to find which sub-object in a multi-object
    # is the main one (name closest to the file's one).
    # CHECK IF IT'S JUST THE FIRST ONE CONSISTENTLY (ALTHOUGH
    # BPY.DATA.OBJECTS MIGHT DISORDER THEM) OR IF
    # THERE IS SOME SIMPLE HEURISTIC (UNDERLINES?)
    closest_match = strings_list[0] # a default winner if all are equally bad
    highest_closeness = 0
    for candidate_string in strings_list:
        closeness = count_matching_characters(reference_string, candidate_string)
        if closeness > highest_closeness:
            highest_closeness = closeness
            closest_match = candidate_string
    return closest_match

# UNUSED DISCARDED
def count_matching_characters(string1, string2):
    # A gross and cheap approach to calculating
    # the "distance" between two strings
    # by checking how many characters match.

    """
    Counts the number of matching characters between two strings.

    Args:
        string1 (str): The first string.
        string2 (str): The second string.

    Returns:
        int: The number of matching characters.
    """
    # Initialize a counter for the number of matching characters.
    count = 0

    # Iterate over the characters in the first string.
    for char in string1:
        # If the character is also in the second string, increment the counter.
        if char in string2:
            count += 1

    # Return the number of matching characters.
    return count


def replace_with_empty(obj):
    """
    ChatGPT-generated code (like pulling teeth).
    Preserves the object's original name
    (and its parent, children and Collections state).

    Args:
        obj (bpy.types.Object): object to be replaced.

    Returns:
        obj (bpy.types.Object): replacement Empty object.
    """    

    # No checks to force exception if wrongly fed.
    # if obj is None:
    #     print("Object is None. Exiting.")
    #     return
    
    
    # Save the object's name and world transformation matrix
    obj_name = obj.name
    obj_matrix_world = obj.matrix_world.copy()
    
    # Save the parent
    parent = obj.parent
    
    # Save the children and their world matrices
    children = [(child, child.matrix_world.copy()) for child in obj.children]
    
    # Save the collections the object is in
    collections = [coll for coll in obj.users_collection]
    
    # Create a new empty object
    empty = bpy.data.objects.new(f"{obj.name}_empty", None)
    bpy.context.collection.objects.link(empty)
    
    # Set the empty's world transformation to match the original object
    empty.matrix_world = obj_matrix_world
    
    # Set the parent of the empty to be the same as the original object's parent
    if parent is not None:
        empty.parent = parent
        empty.matrix_parent_inverse = obj.matrix_parent_inverse
    
    # Add the empty to the same collections as the original object
    for coll in collections:
        coll.objects.link(empty)

    # Re-parent the children to the empty and restore their world transformations
    for child, world_matrix in children:
        child.parent = empty
        child.matrix_world = world_matrix
    
    # Optionally, transfer custom properties, constraints, etc. from the original object to the empty
    for prop in obj.keys():
        if prop not in "_RNA_UI":
            empty[prop] = obj[prop]
    
    # Store the object's name
    obj_name = obj.name
    
    # Remove the empty from the default collection (where it was originally linked)
    bpy.context.collection.objects.unlink(empty)
    
    # Delete the original object
    bpy.data.objects.remove(obj)

    # Make sure empty's name is correct after original object
    # is no more and its name has been freed, to avoid .001s
    # (BF intends to make collisions control stricter in the future).
    empty.name = obj_name

    return empty


def separate_by_specific_materials(obj_or_obj_name, materials_names, separate = True):

    """
    Separates an object's polys associated to specified materials
    into separate objects per those materials. By default it
    deletes those polys and materials from the original object.
    
    Args:
        obj_or_obj_name (bpy.types.object or string): object to be separated.
        materials_names (list): list of materials names.
        separate (bool, optional): If False, no separate objects are produced and the polys are just deleted.
    Returns:
        list of bpy.types.object: list of separated objects, empty if there were no materials matches.
    """

    if type(obj_or_obj_name) == str:
        original_obj = bpy.data.objects[obj_or_obj_name]
    else:
        original_obj = obj_or_obj_name
        
    original_mesh = original_obj.data
    new_objs = []
    
    # Get material indices to separate
    mat_indices = [i for i, mat in enumerate(original_mesh.materials) if mat.name in materials_names]
    
    if separate:
        for mat_index in mat_indices:
            # Create a duplicate object
            new_obj = original_obj.copy()
            new_obj.data = original_obj.data.copy()
            bpy.context.collection.objects.link(new_obj)
            new_obj.name = f"{original_obj.name}_{original_mesh.materials[mat_index].name}"
            
            # Create a new bmesh to work with
            bm = bmesh.new()
            bm.from_mesh(new_obj.data)
            
            # Iterate through all faces and hide those that don't use the current material
            faces_to_delete = [f for f in bm.faces if f.material_index != mat_index]
            bmesh.ops.delete(bm, geom=faces_to_delete, context='FACES')
            
            # Update the mesh
            bm.to_mesh(new_obj.data)
            bm.free()
            
            new_objs.append(new_obj)
    
    # Update original object to remove specified materials' polys
    bm = bmesh.new()
    bm.from_mesh(original_mesh)
    faces_to_delete = [f for f in bm.faces if f.material_index in mat_indices]
    bmesh.ops.delete(bm, geom=faces_to_delete, context='FACES')
    bm.to_mesh(original_mesh)
    bm.free()

    # Update original object to remove specified materials' material slots
    for i, slot in enumerate(original_obj.material_slots[:]):  # Use a copy of the list to modify it safely
        if slot.material and slot.material.name in materials_names:
            # Remove the material slot by removing
            # the object.data.materials' element
            original_obj.data.materials.pop(index=i)

    return new_objs



def selectparents():
    deselectall()
    if bpy.data.objects:
        for obj in bpy.data.objects:
            if "swtor_parent_id" in obj.keys():
                obj.select_set( obj["swtor_parent_id"] == "0" )

    return


def selectall():
    bpy.ops.object.select_all(action='SELECT')

    for obj in bpy.data.objects:
       if obj.type == 'MESH':
           obj.select_set(True)
    return


# WHY NOT OPS-BASED?
def deselectall():
    for obj in bpy.data.objects:
        obj.select_set(False)
    return




# Create objects-fitting Empties (not in use yet)
def encase_objects_with_empty(objects, empty_name = "Empty", collection_name = ""):
    # Create a new Empty object
    empty = bpy.data.objects.new(empty_name, None)
    if collection_name == "":
        bpy.context.collection.objects.link(empty)
    else:
        if collection_name not in bpy.data.collections:
            bpy.data.collections.new(collection_name)
        bpy.data.collections[collection_name].objects.link(empty)
        
    # Set the Empty object's display type to 'CUBE'
    empty.empty_display_type = 'CUBE'

    # Set the Empty object's origin to the center of its base
    empty.matrix_world = calculate_base_center_matrix(objects)

    # Parent objects to the Empty object
    for obj in objects:
        obj.parent = empty
        
    return empty
    
def calculate_base_center_matrix(objects):
    # Find the minimum and maximum coordinates of all objects' bounding boxes
    min_x, min_y, min_z = float('inf'), float('inf'), float('inf')
    max_x, max_y, max_z = float('-inf'), float('-inf'), float('-inf')

    for obj in objects:
        bbox = obj.bound_box
        for vertex in bbox:
            min_x = min(min_x, vertex[0])
            min_y = min(min_y, vertex[1])
            min_z = min(min_z, vertex[2])
            max_x = max(max_x, vertex[0])
            max_y = max(max_y, vertex[1])
            max_z = max(max_z, vertex[2])

    # Calculate the center of the base
    base_center = (
        (min_x + max_x) / 2,
        (min_y + max_y) / 2,
        min_z
    )

    # Calculate the translation vector to move the origin
    translation_vector = -base_center

    # Create a translation matrix
    translation_matrix = Matrix.Translation(translation_vector)

    return translation_matrix



#   LATEST VERSION

# MINOR UTILITY CONSOLE FUNCTIONS -----------------------------------------------

@contextlib.contextmanager
def suppress_stdout(suppress=True):
    # Console output supressor for hiding the .gr2 addon's output.
    # Use suppress=False to allow for specific outputs
    # in the middle of a suppressed block of code.
    # Usage is:
    # with suppress_stdout():
    #     <code to be suppressed here>
    #     Use suppress=False to allow for specific outputs
    #     in the middle of a suppressed block of code.

    # (No need to explicitly stop suppression).
    if suppress:
        with io.StringIO() as buffer:
            old_stdout = sys.stdout
            sys.stdout = buffer
            try:
                yield
            finally:
                sys.stdout = old_stdout
    else:
        yield


# Create objects-fitting Empties (not in use yet)
def encase_objects_with_empty(objects, empty_name = "Empty", collection_name = ""):
    # Create a new Empty object
    empty = bpy.data.objects.new(empty_name, None)
    if collection_name == "":
        bpy.context.collection.objects.link(empty)
    else:
        if collection_name not in bpy.data.collections:
            bpy.data.collections.new(collection_name)
        bpy.data.collections[collection_name].objects.link(empty)
        
    # Set the Empty object's display type to 'CUBE'
    empty.empty_display_type = 'CUBE'

    # Set the Empty object's origin to the center of its base
    empty.matrix_world = calculate_base_center_matrix(objects)

    # Parent objects to the Empty object
    for obj in objects:
        obj.parent = empty
        
    return empty
    
def calculate_base_center_matrix(objects):
    # Find the minimum and maximum coordinates of all objects' bounding boxes
    min_x, min_y, min_z = float('inf'), float('inf'), float('inf')
    max_x, max_y, max_z = float('-inf'), float('-inf'), float('-inf')

    for obj in objects:
        bbox = obj.bound_box
        for vertex in bbox:
            min_x = min(min_x, vertex[0])
            min_y = min(min_y, vertex[1])
            min_z = min(min_z, vertex[2])
            max_x = max(max_x, vertex[0])
            max_y = max(max_y, vertex[1])
            max_z = max(max_z, vertex[2])

    # Calculate the center of the base
    base_center = (
        (min_x + max_x) / 2,
        (min_y + max_y) / 2,
        min_z
    )

    # Calculate the translation vector to move the origin
    translation_vector = -base_center

    # Create a translation matrix
    translation_matrix = Matrix.Translation(translation_vector)

    return translation_matrix




def offset_origin(obj, offset_x=0.0, offset_y=0.0, offset_z=0.0):
    '''
    Offset the polys of an object's mesh
    without moving the object's origin
    '''
    # Ensure we're in object mode
    if bpy.context.object.mode != 'OBJECT':
        bpy.ops.object.mode_set(mode='OBJECT')
    
    # Get the mesh data
    mesh = obj.data
    
    # Create a bmesh from the mesh data
    bm = bmesh.new()
    bm.from_mesh(mesh)
    
    # Apply the offset to the vertices in the bmesh
    for vert in bm.verts:
        vert.co += Vector( (offset_x, offset_y, offset_z) )
    
    # Update the mesh data from the bmesh
    bm.to_mesh(mesh)
    mesh.update()
    
    # Reset the bmesh
    bm.free()





# UNUSED: THE OPS ISN'T WORKING
def hide_outliner_one_level():

    # Select overriding method depending on Blender's version.
    # Starting in 3.2 context overrides are deprecated in favor of temp_override
    # https://docs.blender.org/api/3.2/bpy.types.Context.html#bpy.types.Context.temp_override
    #
    # They are scheduled to be removed in 3.3

    version = bpy.app.version
    major = version[0]
    minor = version[1]
    if major < 3 or (major == 3 and minor < 2):
        use_temp_override = False
    else:
        use_temp_override = True

    # window = current Blender app's window in focus
    window = bpy.context.window
    # screen = current Workspace
    screen = window.screen
    # areas = editors and others. There can be several areas of a same type
    areas  = [area for area in screen.areas if area.type == 'OUTLINER']

    for area in areas:
        
        outliner_area = area.spaces.active
        
        display_mode = outliner_area.display_mode
        
        if display_mode == "VIEW_LAYER":

            # Regions refer to "physical" regions inside an area: HEADER, WINDOW… (messy terminology)
            region = [region for region in area.regions if region.type == 'WINDOW'][0]
            
            override = {
                'window': window,
                'screen': screen,
                'area': area,
                'region': region,
            }

            if use_temp_override:
                with bpy.context.temp_override(window=window,
                                            screen=screen,
                                            area=area,
                                            region=region
                                            ):
                    bpy.ops.outliner.show_one_level(override, open=False)
                    outliner_area.tag_redraw()
            else:
                bpy.ops.outliner.show_one_level(override, open=False)
                outliner_area.tag_redraw()

    return



# Functions for managing Collections in the Outliner

# THIS IS PROBABLY NOT WORKING
def iterate_collections(collection, function):
    # (its only use in this operator is passing it
    # exclude_collection_lights, which excludes
    # the collection from the view_layer, but that
    # fn is known not to be working)
    #
    # Define a function to recursively iterate over
    # all collections in a hierarchy and apply
    # a function to them.

    function(collection)
    
    # Recursively iterate over all child collections
    for child_collection in collection.children:
        iterate_collections(child_collection, function)

def exclude_collection_lights(collection):
    # DOESN'T WORK (collections don't
    # have an .exclude method)
    if " - Lights" in collection.name:
        collection.exclude = True
        

def hide_collection_children(collection):
    for child in collection.children:
        child.hide_viewport = True

def link_objects_to_collection (objects, collection, move = False):
    """
    Links objects to a Collection. If move == True,
    it unlinks the objects from their current Collections first.
    Accepts a single object or a list of objects. 
    """

    # Make sure objects works as a list for the loop.
    if not isinstance(objects, list):
        objects = [objects]

    for object in objects:
        # First, unlink from any collections it is in.
        if object.users_collection and move == True:
            for current_collections in object.users_collection:
                current_collections.objects.unlink(object)

        # Then link to collection.
        collection.objects.link(object)

    return


def parent_with_transformations(obj_to_parent, parent_obj, inherit_transformations=True):
    """
    Parents an object to another, inheriting its transformations
    (plain .parent method-style) or not (imitating bpy.ops).
    Args:
        obj_to_parent (_type_): bpy.data.object.
        parent_obj (_type_): bpy.data.object.
        inherit_transformations (bool, optional): defaults to True.
    """
    # Clear any existing parent-child relationship
    obj_to_parent.parent = None
    
    # Set new parent-child relationship
    obj_to_parent.parent = parent_obj
    
    # Inherit transformations
    if inherit_transformations:
        # Get parent's world matrix
        parent_matrix = parent_obj.matrix_world
        
        # Apply parent's world matrix to child's local matrix
        obj_to_parent.matrix_local = parent_matrix @ obj_to_parent.matrix_local
    
    # Clear child's transformation if not inheriting transformations
    else:
        obj_to_parent.location = (0,0,0)
        obj_to_parent.rotation_euler = (0,0,0)
        obj_to_parent.scale = (1,1,1)

    return


# UNUSED DISCARDED
def find_closest_match(strings_list, reference_string):
    
    # Finds the closest match to a reference string
    # among the strings in a list.
    # Meant to find which sub-object in a multi-object
    # is the main one (name closest to the file's one).
    # CHECK IF IT'S JUST THE FIRST ONE CONSISTENTLY (ALTHOUGH
    # BPY.DATA.OBJECTS MIGHT DISORDER THEM) OR IF
    # THERE IS SOME SIMPLE HEURISTIC (UNDERLINES?)
    closest_match = strings_list[0] # a default winner if all are equally bad
    highest_closeness = 0
    for candidate_string in strings_list:
        closeness = count_matching_characters(reference_string, candidate_string)
        if closeness > highest_closeness:
            highest_closeness = closeness
            closest_match = candidate_string
    return closest_match

# UNUSED DISCARDED
def count_matching_characters(string1, string2):
    # A gross and cheap approach to calculating
    # the "distance" between two strings
    # by checking how many characters match.

    """
    Counts the number of matching characters between two strings.

    Args:
        string1 (str): The first string.
        string2 (str): The second string.

    Returns:
        int: The number of matching characters.
    """
    # Initialize a counter for the number of matching characters.
    count = 0

    # Iterate over the characters in the first string.
    for char in string1:
        # If the character is also in the second string, increment the counter.
        if char in string2:
            count += 1

    # Return the number of matching characters.
    return count


def replace_with_empty(blender_object):
    # ChatGPT-generated code. Needs checking.
    # Preserves the object's original name (and its parent and children relationships,
    # just in case it's necessary): if the object has a parent, its parent relationship
    # is preserved by setting the new empty's parent to the original parent
    # and calculating the inverse transform matrix. Each child of the original object
    # is also updated to have the new empty as its parent.
    
    # Store object properties
    obj_name = blender_object.name

    obj_parent = blender_object.parent
    obj_children = blender_object.children[:]
    obj_matrix_local = blender_object.matrix_local.copy()
    obj_matrix_world = blender_object.matrix_world.copy()

    # Create empty object
    empty = bpy.data.objects.new(obj_name, None)
    empty.empty_display_size = 1.0
    empty.empty_display_type = 'CUBE'
    bpy.context.collection.objects.link(empty)

    # Set empty object properties
    empty.matrix_local = obj_matrix_local
    empty.matrix_world = obj_matrix_world

    # Set parent relationship
    if obj_parent:
        empty.parent = obj_parent
        empty.matrix_parent_inverse.copy_from(blender_object.matrix_parent_inverse)
        empty.parent_type = blender_object.parent_type
        empty.parent_space = blender_object.parent_space
        empty.parent_inverse = blender_object.parent_inverse
        
    # Set children relationships
    for child in obj_children:
        child.parent = empty


    # Delete original object
    bpy.data.objects.remove(blender_object, do_unlink=True)

    # Make sure empty's name is correct after original object
    # is no more and its name has been freed, to avoid .001s
    empty.name = obj_name

    return empty



def selectparents():
    deselectall()
    if bpy.data.objects:
        for obj in bpy.data.objects:
            if "swtor_parent_id" in obj.keys():
                obj.select_set( obj["swtor_parent_id"] == "0" )

    return


def selectall():
    bpy.ops.object.select_all(action='SELECT')

    for obj in bpy.data.objects:
       if obj.type == 'MESH':
           obj.select_set(True)
    return


# WHY NOT OPS-BASED?
def deselectall():
    for obj in bpy.data.objects:
        obj.select_set(False)
    return







# CURRENTLY ACTIVE

@contextlib.contextmanager
def suppress_stdout(suppress=True):
    # Console output supressor for hiding the .gr2 addon's output.
    # Use suppress=False to allow for specific outputs
    # in the middle of a suppressed block of code.
    # Usage is:
    # with suppress_stdout():
    #     <code to be suppressed here>
    #     Use suppress=False to allow for specific outputs
    #     in the middle of a suppressed block of code.

    # (No need to explicitly stop suppression).
    if suppress:
        with io.StringIO() as buffer:
            old_stdout = sys.stdout
            sys.stdout = buffer
            try:
                yield
            finally:
                sys.stdout = old_stdout
    else:
        yield


# Create objects-fitting Empties (not in use yet)
def encase_objects_with_empty(objects, empty_name = "Empty", collection_name = ""):
    # Create a new Empty object
    empty = bpy.data.objects.new(empty_name, None)
    if collection_name == "":
        bpy.context.collection.objects.link(empty)
    else:
        if collection_name not in bpy.data.collections:
            bpy.data.collections.new(collection_name)
        bpy.data.collections[collection_name].objects.link(empty)
        
    # Set the Empty object's display type to 'CUBE'
    empty.empty_display_type = 'CUBE'

    # Set the Empty object's origin to the center of its base
    empty.matrix_world = calculate_base_center_matrix(objects)

    # Parent objects to the Empty object
    for obj in objects:
        obj.parent = empty
        
    return empty
    
def calculate_base_center_matrix(objects):
    # Find the minimum and maximum coordinates of all objects' bounding boxes
    min_x, min_y, min_z = float('inf'), float('inf'), float('inf')
    max_x, max_y, max_z = float('-inf'), float('-inf'), float('-inf')

    for obj in objects:
        bbox = obj.bound_box
        for vertex in bbox:
            min_x = min(min_x, vertex[0])
            min_y = min(min_y, vertex[1])
            min_z = min(min_z, vertex[2])
            max_x = max(max_x, vertex[0])
            max_y = max(max_y, vertex[1])
            max_z = max(max_z, vertex[2])

    # Calculate the center of the base
    base_center = (
        (min_x + max_x) / 2,
        (min_y + max_y) / 2,
        min_z
    )

    # Calculate the translation vector to move the origin
    translation_vector = -base_center

    # Create a translation matrix
    translation_matrix = Matrix.Translation(translation_vector)

    return translation_matrix




def offset_origin(obj, offset_x=0.0, offset_y=0.0, offset_z=0.0):
    '''
    Offset the polys of an object's mesh
    without moving the object's origin
    '''
    # Ensure we're in object mode
    if bpy.context.object.mode != 'OBJECT':
        bpy.ops.object.mode_set(mode='OBJECT')
    
    # Get the mesh data
    mesh = obj.data
    
    # Create a bmesh from the mesh data
    bm = bmesh.new()
    bm.from_mesh(mesh)
    
    # Apply the offset to the vertices in the bmesh
    for vert in bm.verts:
        vert.co += Vector( (offset_x, offset_y, offset_z) )
    
    # Update the mesh data from the bmesh
    bm.to_mesh(mesh)
    mesh.update()
    
    # Reset the bmesh
    bm.free()





# UNUSED: THE OPS ISN'T WORKING
def hide_outliner_one_level():

    # Select overriding method depending on Blender's version.
    # Starting in 3.2 context overrides are deprecated in favor of temp_override
    # https://docs.blender.org/api/3.2/bpy.types.Context.html#bpy.types.Context.temp_override
    #
    # They are scheduled to be removed in 3.3

    version = bpy.app.version
    major = version[0]
    minor = version[1]
    if major < 3 or (major == 3 and minor < 2):
        use_temp_override = False
    else:
        use_temp_override = True

    # window = current Blender app's window in focus
    window = bpy.context.window
    # screen = current Workspace
    screen = window.screen
    # areas = editors and others. There can be several areas of a same type
    areas  = [area for area in screen.areas if area.type == 'OUTLINER']

    for area in areas:
        
        outliner_area = area.spaces.active
        
        display_mode = outliner_area.display_mode
        
        if display_mode == "VIEW_LAYER":

            # Regions refer to "physical" regions inside an area: HEADER, WINDOW… (messy terminology)
            region = [region for region in area.regions if region.type == 'WINDOW'][0]
            
            override = {
                'window': window,
                'screen': screen,
                'area': area,
                'region': region,
            }

            if use_temp_override:
                with bpy.context.temp_override(window=window,
                                            screen=screen,
                                            area=area,
                                            region=region
                                            ):
                    bpy.ops.outliner.show_one_level(override, open=False)
                    outliner_area.tag_redraw()
            else:
                bpy.ops.outliner.show_one_level(override, open=False)
                outliner_area.tag_redraw()

    return



# Functions for managing Collections in the Outliner

# THIS IS PROBABLY NOT WORKING
def iterate_collections(collection, function):
    # (its only use in this operator is passing it
    # exclude_collection_lights, which excludes
    # the collection from the view_layer, but that
    # fn is known not to be working)
    #
    # Define a function to recursively iterate over
    # all collections in a hierarchy and apply
    # a function to them.

    function(collection)
    
    # Recursively iterate over all child collections
    for child_collection in collection.children:
        iterate_collections(child_collection, function)

def exclude_collection_lights(collection):
    # DOESN'T WORK (collections don't
    # have an .exclude method)
    if " - Lights" in collection.name:
        collection.exclude = True
        

def hide_collection_children(collection):
    for child in collection.children:
        child.hide_viewport = True

def link_objects_to_collection (objects, collection, move = False):
    """
    Links objects to a Collection. If move == True,
    it unlinks the objects from their current Collections first.
    Accepts a single object or a list of objects. 
    """

    # Make sure objects works as a list for the loop.
    if not isinstance(objects, list):
        objects = [objects]

    for object in objects:
        # First, unlink from any collections it is in.
        if object.users_collection and move == True:
            for current_collections in object.users_collection:
                current_collections.objects.unlink(object)

        # Then link to collection.
        collection.objects.link(object)

    return


def parent_with_transformations(obj_to_parent, parent_obj, inherit_transformations=True):
    """
    Parents an object to another, inheriting its transformations
    (plain .parent method-style) or not (imitating bpy.ops).
    Args:
        obj_to_parent (_type_): bpy.data.object.
        parent_obj (_type_): bpy.data.object.
        inherit_transformations (bool, optional): defaults to True.
    """
    # Clear any existing parent-child relationship
    obj_to_parent.parent = None
    
    # Set new parent-child relationship
    obj_to_parent.parent = parent_obj
    
    # Inherit transformations
    if inherit_transformations:
        # Get parent's world matrix
        parent_matrix = parent_obj.matrix_world
        
        # Apply parent's world matrix to child's local matrix
        obj_to_parent.matrix_local = parent_matrix @ obj_to_parent.matrix_local
    
    # Clear child's transformation if not inheriting transformations
    else:
        obj_to_parent.location = (0,0,0)
        obj_to_parent.rotation_euler = (0,0,0)
        obj_to_parent.scale = (1,1,1)

    return


# UNUSED DISCARDED
def find_closest_match(strings_list, reference_string):
    
    # Finds the closest match to a reference string
    # among the strings in a list.
    # Meant to find which sub-object in a multi-object
    # is the main one (name closest to the file's one).
    # CHECK IF IT'S JUST THE FIRST ONE CONSISTENTLY (ALTHOUGH
    # BPY.DATA.OBJECTS MIGHT DISORDER THEM) OR IF
    # THERE IS SOME SIMPLE HEURISTIC (UNDERLINES?)
    closest_match = strings_list[0] # a default winner if all are equally bad
    highest_closeness = 0
    for candidate_string in strings_list:
        closeness = count_matching_characters(reference_string, candidate_string)
        if closeness > highest_closeness:
            highest_closeness = closeness
            closest_match = candidate_string
    return closest_match

# UNUSED DISCARDED
def count_matching_characters(string1, string2):
    # A gross and cheap approach to calculating
    # the "distance" between two strings
    # by checking how many characters match.

    """
    Counts the number of matching characters between two strings.

    Args:
        string1 (str): The first string.
        string2 (str): The second string.

    Returns:
        int: The number of matching characters.
    """
    # Initialize a counter for the number of matching characters.
    count = 0

    # Iterate over the characters in the first string.
    for char in string1:
        # If the character is also in the second string, increment the counter.
        if char in string2:
            count += 1

    # Return the number of matching characters.
    return count


def replace_with_empty(blender_object):
    # ChatGPT-generated code. Needs checking.
    # Preserves the object's original name (and its parent and children relationships,
    # just in case it's necessary): if the object has a parent, its parent relationship
    # is preserved by setting the new empty's parent to the original parent
    # and calculating the inverse transform matrix. Each child of the original object
    # is also updated to have the new empty as its parent.
    
    # Store object properties
    obj_name = blender_object.name

    obj_parent = blender_object.parent
    obj_children = blender_object.children[:]
    obj_matrix_local = blender_object.matrix_local.copy()
    obj_matrix_world = blender_object.matrix_world.copy()

    # Create empty object
    empty = bpy.data.objects.new(obj_name, None)
    empty.empty_display_size = 1.0
    empty.empty_display_type = 'CUBE'
    bpy.context.collection.objects.link(empty)

    # Set empty object properties
    empty.matrix_local = obj_matrix_local
    empty.matrix_world = obj_matrix_world

    # Set parent relationship
    if obj_parent:
        empty.parent = obj_parent
        empty.matrix_parent_inverse.copy_from(blender_object.matrix_parent_inverse)
        empty.parent_type = blender_object.parent_type
        empty.parent_space = blender_object.parent_space
        empty.parent_inverse = blender_object.parent_inverse
        
    # Set children relationships
    for child in obj_children:
        child.parent = empty


    # Delete original object
    bpy.data.objects.remove(blender_object, do_unlink=True)

    # Make sure empty's name is correct after original object
    # is no more and its name has been freed, to avoid .001s
    empty.name = obj_name

    return empty



def selectparents():
    deselectall()
    if bpy.data.objects:
        for obj in bpy.data.objects:
            if "swtor_parent_id" in obj.keys():
                obj.select_set( obj["swtor_parent_id"] == "0" )

    return


def selectall():
    bpy.ops.object.select_all(action='SELECT')

    for obj in bpy.data.objects:
       if obj.type == 'MESH':
           obj.select_set(True)
    return


# WHY NOT OPS-BASED?
def deselectall():
    for obj in bpy.data.objects:
        obj.select_set(False)
    return








def selected_collections():
    '''
    Returns selected collections
    in Outliner
    '''
    
    context = bpy.context

    selected_collections = []

    screen=context.window.screen
    for window in context.window_manager.windows:
        for area in window.screen.areas:
            if area.type == 'OUTLINER':
                for region in area.regions:
                    if region.type == 'WINDOW':
                        with context.temp_override(
                            screen=screen,
                            window=window,
                            area=area,
                            region=region,
                        ):
                            if context.space_data.display_mode == "VIEW_LAYER":
                                for item in context.selected_ids:
                                    if item.bl_rna.identifier == "Collection":
                                        selected_collections.append(item)
                                # We can break the area looping here
                                return selected_collections
                                
    return selected_collections



def create_layer_collections_dictionary():
    '''
    Creates a dict with:
        key=layer_collection.name
        value=layer_collection object
    so that we can match collections to their
    layer_collections and use .include = True or False
    on them.
    '''

    # Get the current context and view layer
    context = bpy.context
    view_layer = context.view_layer

    # Initialize an empty dictionary to store layer collections
    layer_collections_dict = {}

    # Include the view layer itself in the dictionary
    layer_collections_dict[view_layer.name] = view_layer

    # Include the direct children of the view layer
    for direct_child_collection in view_layer.layer_collection.children:
        layer_collections_dict[direct_child_collection.name] = direct_child_collection
        # Recursively populate the dictionary with collections and their child collections
        recursive_collect_collections(direct_child_collection, layer_collections_dict)

    return layer_collections_dict

def recursive_collect_collections(collection, result_dict):
    # Recursively collect all child collections
    for child_collection in collection.children:
        # Use the .name property as the key and the layer collection object as the value
        result_dict[child_collection.name] = child_collection
        # Recursively process child collections
        recursive_collect_collections(child_collection, result_dict)












# -------------------------------------------------------------------------------------------------
def merge_materials_node_trees(source_material_name,
                                destination_material_name,
                                offset_x = 0.0,
                                offset_y = 0.0,
                                delete_source_output_nodes = False,
                                delete_destination_output_nodes = False):
    """
    Adds the entire node tree of a source material to the node tree of a
    destination material, resulting in both sets of nodes inside the
    destination material's node tree.
    
    It lets us offset the source's nodes in Shader Editor space coordinate units
    to keep them from overlapping.
    
    It doesn't delete any Output Node by default (which can be actually useful
    in certain situations, as Blender lets us select which Output Node among many
    is the one currently producing the material's output).
    
    Args:
        source_material_name (string): material with node tree to copy.
        destination_material_name (string): material receiving the nodes.

        offset_x (float, optional): displace the source's nodes in Shader Editor space. Defaults to 0.0.
        offset_y (float, optional): displace the source's nodes in Shader Editor space. Defaults to 0.0.
        
        delete_source_output_node (bool, optional): omits the Output Node from the source material. Defaults to False.
        delete_destination_output_node (bool, optional): deletes the Output Node from the source material. Defaults to False.
        (WARNING: in case of multiple Output Nodes in the source material or in the destination one, these options will omit
        or delete all applicable Output Nodes)

    Returns:
        Bool: True if successful, False if any of the materials doesn't exist.
    """
    
    # Get the source and destination materials
    source_material = bpy.data.materials.get(source_material_name)
    destination_material = bpy.data.materials.get(destination_material_name)

    # Check if both materials exist
    if not source_material:
        print(f"Error: the '{source_material_name}' Material does not exist.")
        return False
    
    if not destination_material:
        print(f"Error: the '{destination_material_name}' Material does not exist.")
        return False

    # Get the node trees of the materials
    source_node_tree = source_material.node_tree
    destination_node_tree = destination_material.node_tree
    
    
    # Delete destination material's Outputs Nodes if set so in args
    if delete_destination_output_nodes:
        for node in destination_node_tree.nodes:
            if node.bl_idname == 'ShaderNodeOutputMaterial':
                destination_node_tree.nodes.remove(node)


    # Create a dict relating the source's nodes
    # and their copies created into the destination.
    # It will be used for reading the source ones' linkings
    # and apply them to the copied ones.
    node_mapping = {}

    # Add nodes to the destination node tree
    for source_node in source_node_tree.nodes:
        
        # Omit processing the source material's Output Node if set so in args
        if source_node.bl_idname == 'ShaderNodeOutputMaterial' and delete_source_output_nodes:
            continue
        
        # Create copy of source node in the destination node tree
        new_node = destination_node_tree.nodes.new(type=source_node.bl_idname)
        
        # Add the mapping between source and destination nodes
        node_mapping[source_node] = new_node
        
        new_node.name = source_node.name
        new_node.label = source_node.label
        new_node.location[0] = source_node.location + offset_x
        new_node.location[1] = source_node.location + offset_y
        new_node.hide = source_node.hide
        new_node.use_custom_color = source_node.use_custom_color
        new_node.color = source_node.color


    # Add links to the destination node tree
    for source_link in source_node_tree.links:
        source_socket = node_mapping.get(source_link.from_node).outputs[source_link.from_socket.name]
        destination_socket = node_mapping.get(source_link.to_node).inputs[source_link.to_socket.name]
        
        # Omit processing the source material's links to their Output Nodes if set so in args
        # as those nodes won't exist
        if source_link.to_node.bl_idname == 'ShaderNodeOutputMaterial' and delete_source_output_nodes:
            continue

        destination_node_tree.links.new(source_socket, destination_socket)
    
    return True
        
# -------------------------------------------------------------------------------------------------



def selected_objects_in_3d_view(context):
    if bpy.context.mode == "OBJECT" and bpy.context.selected_objects:
        enable_operator = True
    else:
        enable_operator = False
        for window in context.window_manager.windows:
            for area in window.screen.areas:
                if area.type == 'OUTLINER':
                    with context.temp_override(window=window, area=area):
                        if context.selected_ids:
                            for item in context.selected_ids:
                                if item.type == "MESH":
                                    enable_operator = True
                                    break
    return enable_operator


def selected_objects_in_outliner(context):
    enable_operator = False
    for window in context.window_manager.windows:
        for area in window.screen.areas:
            if area.type == 'OUTLINER':
                with context.temp_override(window=window, area=area):
                    if context.selected_ids:
                        for item in context.selected_ids:
                            if item.type == "MESH":
                                enable_operator = True
                                break
    return enable_operator




def selected_collections():
    '''
    Returns selected collections
    in Outliner
    '''
    
    context = bpy.context

    selected_collections = []

    screen=context.window.screen
    for window in context.window_manager.windows:
        for area in window.screen.areas:
            if area.type == 'OUTLINER':
                for region in area.regions:
                    if region.type == 'WINDOW':
                        with context.temp_override(
                            screen=screen,
                            window=window,
                            area=area,
                            region=region,
                        ):
                            if context.space_data.display_mode == "VIEW_LAYER":
                                for item in context.selected_ids:
                                    if item.bl_rna.identifier == "Collection":
                                        selected_collections.append(item)
                                # We can break the area looping here
                                return selected_collections
                                
    return selected_collections












def sort_all_collections():
    '''
    https://blender.stackexchange.com/questions/157562/sorting-collections-alphabetically-in-the-outliner
    Unlinks all collections and relinks them by alphabetical order,
    as Blender only orders collections by the order they were linked
    (the Outliner only sorts objects alphabetically, not Collections).
    Works through all Scenes in the Blender project.
    '''
    collections = bpy.data.collections[:]
    collections.extend(scene.collection for scene in bpy.data.scenes)
    for col in collections:
        for c in sorted(col.children, key=lambda c: c.name.lower()):
            col.children.unlink(c)
            col.children.link(c)


def sort_selected_collection():
    '''
    https://blender.stackexchange.com/questions/157562/sorting-collections-alphabetically-in-the-outliner
    '''
    context = bpy.context

    def all_colls(c):
        def walk(col):
            yield col
            for c in col.children:
                yield from walk(c)
        return set(walk(c))

    assert(context.collection) # poll cannot be None.

    for col in all_colls(context.collection):
        for c in sorted(col.children, key=lambda c: c.name.lower()):
            col.children.unlink(c)
            col.children.link(c)


def get_collections_hierarchy():
    '''
    Generates a dict with collections' names as keys
    and a list of their parent collections' names as values
    '''
    def find_parent_collection(child_collection):
        # Iterate through all collections in the scene
        for collection in bpy.data.collections:
            if child_collection.name in collection.children.keys():
                return collection
        return None

    collections_dict = {}
    
    # Iterate through all collections in the scene
    for collection in bpy.data.collections:
        parent_collection = find_parent_collection(collection)
        if parent_collection:
            collections_dict[collection.name] = parent_collection.name
        else:
            collections_dict[collection.name] = None  # No parent collection (it's a top-level collection)
    
    return collections_dict


def collection_has_objects(collection):
    # Check if the collection has any objects directly
    if collection.objects:
        return True
    
    # Recursively check child collections
    for child_collection in collection.children:
        if collection_has_objects(child_collection):
            return True
    
    return False

def flatten_all_collections(cleanup=False):

    collections = bpy.data.collections
    cols_dict = get_collections_hierarchy()

    for col_name in cols_dict:
        if cols_dict[col_name]:
            parent_name = cols_dict[col_name]
            collections[parent_name].children.unlink(collections[col_name])
            
    # if cleanup:
    #     for collection in bpy.data.collections:
    #         if collection.name.startswith("- ") and not collection_has_objects(collection):
    #             bpy.data.collections.remove(collection, do_unlink=True)
                
        







def translate_uv_coordinates(mesh_object, material_slot = None, uv_offset = (0,0) ):
    # uv_offset's default is needed because there can't be args without defaults
    # after an arg with one
    
    '''
    Offset an object's polys' UVs, either all or those
    associated to a material. Motivated by Twi'lek's
    off-image coordinates eye UVs producing black bakes.
    '''
    
    # Ensure the object is a mesh
    if mesh_object.type != 'MESH':
        print("Selected object is not a mesh.")
        return

    # Get the mesh data
    mesh = mesh_object.data

    # Ensure the mesh has UV coordinates
    if not mesh.uv_layers.active:
        print("Mesh has no UV coordinates.")
        return

    # Get the active UV layer
    uv_layer = mesh.uv_layers.active.data

    # Translate UV coordinates
    was_corrected = False  # Set return flag 

    for face in mesh.polygons:
        if face.material_index == material_slot or material_slot == None:
            for loop_index in face.loop_indices:
                uv = uv_layer[loop_index].uv
                if uv.y <= 1:
                    return was_corrected
                uv.x += uv_offset[0]
                uv.y += uv_offset[1]
                was_corrected = True
                
    return was_corrected









def bind_objects_to_armature(objects, armature, single_armature_only=True):
    """
    Bind a set of objects to an armature, producing Armature Modifiers in the process.

    :param objects: A list of objects to be bound to the armature
    :param armature: The armature object
    :param single_armature_only: prevents from adding armatures when there are any already
    """
    for obj in objects:
        # Ensure the object has a mesh data type
        if obj.type == 'MESH':
            # Add an Armature modifier if it doesn't already exist
            # or if it does but we allow multiple ones
            if not ( single_armature_only and any(mod.type == 'ARMATURE' for mod in obj.modifiers) ):
                mod = obj.modifiers.new(name="Armature", type='ARMATURE')
                mod.object = armature
                
                # Create a parent relationship
                # DON'T USE A PARENT_TYPE OF 'ARMATURE'. THE MODIFIER IS DOING THAT ALREADY
                obj.parent = armature
                obj.matrix_parent_inverse = armature.matrix_world.inverted() # Is this necessary?

                # Automatic weight assignment is more complex and would usually require the operator,
                # so here we assume weights have been assigned manually or by another method. For
                # implementing it, it would be bpy.ops.object.parent_set(type='ARMATURE_AUTO')













def get_wrinkles_and_directionmaps(mat_file_abs_path):
    '''Reads a shader .mat file and returns any DirectionMap
    and WrinkleMap paths in an "as is" basis
    (slashes, backslashes, initial ones or not…)'''
    
    relative_paths = []
    with open(mat_file_abs_path, 'r') as mat_file:
        tree = ET.parse(mat_file)
        root = tree.getroot()

        # The diverse camelCases are as per BioWare's horrific inconsistency.
        # Same goes for initial backslash. For consistency, we add it if missing.
        # backslash vs. slash is solved vía pathlib later on.

        DirectionMap = root.find("./input/[semantic='DirectionMap']")
        if DirectionMap != None:
            texturemap_path = DirectionMap.find("value").text + ".dds"
            if texturemap_path[0] != "\\":
                texturemap_path = "\\" + texturemap_path
            relative_paths.append(texturemap_path)

        animatedWrinkleMap = root.find("./input/[semantic='animatedWrinkleMap']")
        if animatedWrinkleMap != None:
            texturemap_path = animatedWrinkleMap.find("value").text + ".dds"
            if texturemap_path[0] != "\\":
                texturemap_path = "\\" + texturemap_path
            relative_paths.append(texturemap_path)

        animatedWrinkleMask = root.find("./input/[semantic='animatedWrinkleMask']")
        if animatedWrinkleMask != None:
            texturemap_path = animatedWrinkleMask.find("value").text + ".dds"
            if texturemap_path[0] != "\\":
                texturemap_path = "\\" + texturemap_path
            relative_paths.append(texturemap_path)

    return(relative_paths)













def link_objects_to_collection(objects, destination_collection, create = True, move = False):
    """
    Links objects to a Collection.
    Accepts both data-blocks and ID strings.
    Accepts a single object or a list of objects. 
    If create == True, creates destination_collection if doesn't exists.
    If move == True,
    it unlinks the objects from their current Collections first.
    """

    if objects:
        # Make sure a single object works as a list for the loop.
        if not isinstance(objects, list):
            objects = [objects]
            
        # if destination_collection is a string, turn it into a data-block.
        if type(destination_collection) == str:
            if destination_collection not in bpy.data.collections:
                if create == True:
                    destination_collection = bpy.data.collections.new(destination_collection)
                else:
                    return False
            else:
                destination_collection = bpy.data.collections[destination_collection]           
                
        for object in objects:
            # if object is a string, turn it into a data-block.
            if type(object) == str:
                object = bpy.data.objects.get(object)
                if object == None:
                    return False
            
            # If move == True, unlink from any collections it is in.
            if object.users_collection and move == True:
                for current_collections in object.users_collection:
                    current_collections.objects.unlink(object)
            # Then link to assigned collection.
            destination_collection.objects.link(object)
            
        # If destination_collection isn't linked to any other Collection
        # including the Scene Collection, link it to the Scene Collection.
        if not bpy.context.scene.user_of_id(destination_collection):
            bpy.context.collection.children.link(destination_collection)

        return
    else:
        return False

def link_collections_to_collection(collections, destination_collection, create = True, move = True):
    """
    Links collections to a Collection.
    Accepts both data-blocks and ID strings.
    Accepts a single collection or a list of collections. 
    If create == True, creates destination_collection if it doesn't exists.
    If move == True, unlink from any collections it is in before placing in destination.

    """

    if collections:
        # Make sure a single collection works as a list for the loop.
        if not isinstance(collections, list):
            collections = [collections]
            
        # if destination_collection is a string, turn it into a data-block.
        if type(destination_collection) == str:
            if destination_collection not in bpy.data.collections:
                if create == True:
                    destination_collection = bpy.data.collections.new(destination_collection)
                else:
                    return False
            else:
                destination_collection = bpy.data.collections[destination_collection]           
                
        for collection in collections:
            # if collection is string turn it into a data-block.
            if type(collection) == str:
                collection = bpy.data.collections.get(collection)
                if collection == None:
                    return False
            
            # If move == True, unlink from any collections it is in.
            if move == True:
                # Unlink from all collections in the scene.
                for scene_collection in list(bpy.context.scene.collection.children_recursive):
                    if collection in list(scene_collection.children):
                        scene_collection.children.unlink(collection)
                # Also unlink from the Scene Collection
                if collection in list(bpy.context.scene.collection.children):
                    bpy.context.scene.collection.children.unlink(collection)
            # Then link to assigned collection.
            destination_collection.children.link(collection)
            
        # If destination_collection isn't linked to any other Collection
        # including the Scene Collection, link it to the Scene Collection.
        if not bpy.context.scene.user_of_id(destination_collection):
            bpy.context.collection.children.link(destination_collection)

        return
    else:
        return False





def duplicate_obj(obj_or_obj_name):
    
    if type(obj_or_obj_name) == str:
        obj = bpy.data.objects[obj_or_obj_name]
    else:
        obj = obj_or_obj_name
        
    # Create a new object data-block that is a copy of the original object's data
    # including transforms, modifiers, constraints, parents and Collections.
    new_data = obj.data.copy()
    
    # Create a new object with the copied data
    new_obj = bpy.data.objects.new(obj.name + ".copy", new_data)
    
    # Link the new object to the same collection(s) as the original object
    for col in obj.users_collection:
        col.objects.link(new_obj)
    
    # Copy all properties from the original object to the new object
    new_obj.location = obj.location.copy()
    new_obj.rotation_euler = obj.rotation_euler.copy()
    new_obj.rotation_quaternion = obj.rotation_quaternion.copy()
    new_obj.scale = obj.scale.copy()
    new_obj.data = new_data
    
    # Copy custom properties
    for prop in obj.keys():
        if prop != "_RNA_UI":  # Ignore the RNA UI property
            new_obj[prop] = obj[prop]
    
# Copy all modifiers
    for mod in obj.modifiers:
        new_mod = new_obj.modifiers.new(name=mod.name, type=mod.type)
        for attr in dir(mod):
            if not attr.startswith("_") and attr not in {"type", "name", "rna_type"}:
                try:
                    setattr(new_mod, attr, getattr(mod, attr))
                except AttributeError:
                    pass
        
        # Special handling for Armature modifiers
        if mod.type == 'ARMATURE':
            new_mod.object = mod.object
        
    # Copy animation data
    if obj.animation_data:
        new_obj.animation_data_create()
        new_obj.animation_data.action = obj.animation_data.action
        new_obj.animation_data.action = obj.animation_data.action.copy()
    
    # Copy constraints
    for constr in obj.constraints:
        new_constr = new_obj.constraints.new(type=constr.type)
        for attr in dir(constr):
            if not attr.startswith("_") and attr not in {"type", "name", "rna_type"}:
                try:
                    setattr(new_constr, attr, getattr(constr, attr))
                except AttributeError:
                    pass
    
    return new_obj



def separate_obj_by_specific_materials(obj_or_obj_name, materials_names, separate = True):

    """
    Separates an object's polys associated to specified materials
    into separate objects per those materials. By default it
    deletes those polys AND materials from the original object.
    
    Args:
        obj_or_obj_name (bpy.types.object or string): object to be separated.
        materials_names (list): list of materials names.
        separate (bool, optional): If False, no separate objects are produced and the polys are just deleted.
    Returns:
        list of bpy.types.object: list of separated objects, empty if there were no materials matches.
    """

    if type(obj_or_obj_name) == str:
        original_obj = bpy.data.objects[obj_or_obj_name]
    else:
        original_obj = obj_or_obj_name
        
    original_mesh = original_obj.data
    new_objs = []
    
    # Get material indices to separate
    mat_indices = [i for i, mat in enumerate(original_mesh.materials) if mat.name in materials_names]
    
    if separate:
        for mat_index in mat_indices:
            # Create a duplicate object
            new_obj = original_obj.copy()
            new_obj.data = original_obj.data.copy()
            bpy.context.collection.objects.link(new_obj)
            new_obj.name = f"{original_obj.name}_{original_mesh.materials[mat_index].name}"
            
            # Create a new bmesh to work with
            bm = bmesh.new()
            bm.from_mesh(new_obj.data)
            
            # Iterate through all faces and hide those that don't use the current material
            faces_to_delete = [f for f in bm.faces if f.material_index != mat_index]
            bmesh.ops.delete(bm, geom=faces_to_delete, context='FACES')
            
            # Update the mesh
            bm.to_mesh(new_obj.data)
            bm.free()
            
            new_objs.append(new_obj)
    
    # Update original object to remove specified materials' polys
    bm = bmesh.new()
    bm.from_mesh(original_mesh)
    faces_to_delete = [f for f in bm.faces if f.material_index in mat_indices]
    bmesh.ops.delete(bm, geom=faces_to_delete, context='FACES')
    bm.to_mesh(original_mesh)
    bm.free()

    # Update original object to remove specified materials' material slots
    for i, slot in enumerate(original_obj.material_slots[:]):  # Use a copy of the list to modify it safely
        if slot.material and slot.material.name in materials_names:
            # Remove the material slot by removing
            # the object.data.materials' element
            original_obj.data.materials.pop(index=i)

    return new_objs

def delete_polygons_on_side(obj_or_obj_name, side='LEFT'):
    
    if type(obj_or_obj_name) == str:
        obj = bpy.data.objects[obj_or_obj_name]
    else:
        obj = obj_or_obj_name

    # Ensure we're in object mode
    if obj.mode != 'OBJECT':
        bpy.ops.object.mode_set(mode='OBJECT')

    # Get the mesh data
    mesh = obj.data

    # Create a BMesh from the mesh data
    bm = bmesh.new()
    bm.from_mesh(mesh)

    # Select polygons based on the side parameter
    for face in bm.faces:
        center = face.calc_center_median()
        if side == 'LEFT' and center.x < 0:
            face.select_set(True)
        elif side == 'RIGHT' and center.x >= 0:
            face.select_set(True)
        else:
            face.select_set(False)

    # Remove the selected faces
    bmesh.ops.delete(bm, geom=[f for f in bm.faces if f.select], context='FACES')

    # Update the mesh with the BMesh data
    bm.to_mesh(mesh)
    bm.free()

    # Update the scene to reflect changes. NECESSARY???
    # mesh.update()  # This refreshes the mesh data
    # obj.data.update()  # Ensure that the object data is up-to-date
    # bpy.context.view_layer.update()  # Refresh the view layer to reflect changes

    print(f"Polygons on the {side} side have been deleted.")





def get_highest_and_lowest_vertices(obj_or_obj_name):
    
    if type(obj_or_obj_name) == str:
        obj = bpy.data.objects[obj_or_obj_name]
    else:
        obj = obj_or_obj_name

    # Ensure we are in object mode
    bpy.ops.object.mode_set(mode='OBJECT')
    
    # Create a bmesh from the object's mesh data
    bm = bmesh.new()
    bm.from_mesh(obj.data)
    
    # Transform matrix to convert local coordinates to global
    global_matrix = obj.matrix_world
    
    highest_vertex = None
    lowest_vertex = None
    
    for v in bm.verts:
        global_coord = global_matrix @ v.co
        if highest_vertex is None or global_coord.z > highest_vertex.z:
            highest_vertex = global_coord
        if lowest_vertex is None or global_coord.z < lowest_vertex.z:
            lowest_vertex = global_coord
    
    bm.free()
    
    return highest_vertex, lowest_vertex

def set_obj_origin(obj_or_obj_name, new_origin):

    if type(obj_or_obj_name) == str:
        obj = bpy.data.objects[obj_or_obj_name]
    else:
        obj = obj_or_obj_name

    new_origin = Vector(new_origin)
    
    # Get the object's world matrix
    obj_matrix = obj.matrix_world
    
    # Calculate the current origin in world space
    current_origin_world = obj_matrix @ Vector((0, 0, 0))
    
    # Calculate the delta vector from current origin to new origin in world space
    delta_world = new_origin - current_origin_world
    
    # Apply the inverse world matrix to get delta in object space
    delta_object_space = obj_matrix.inverted() @ delta_world
    
    # Move the object's location to compensate for the delta
    obj.location += delta_world
    
    # Transform the mesh data to correct for the origin adjustment
    # Note: Applying the inverse translation in object space
    obj.data.transform(Matrix.Translation(-delta_object_space))
    
    # Update the mesh data to apply the changes
    obj.data.update()




def selected_outliner_items(context):
    '''
    Returns selected outliner items
    as a list of RNA objects (in the
    Python sense) including Collections
    '''

    objects_and_collections_in_selection = []

    for window in context.window_manager.windows:
        for area in window.screen.areas:
            if area.type == 'OUTLINER':
                for region in area.regions:
                    if region.type == 'WINDOW':
                        with context.temp_override(window=window, area=area, region=region):
                            for item in context.selected_ids:
                                if item not in objects_and_collections_in_selection:
                                    objects_and_collections_in_selection.append(item)
                                
    return(objects_and_collections_in_selection)
    




def import_url_content(url):
    # Based on https://inventwithpython.com/blog/2022/02/21/downloading-web-pages-and-files-in-python-3-and-2-without-the-requests-module/

    import sys
    if sys.version_info[0] == 3:  # Python 3
        from urllib.request import Request, urlopen
    elif sys.version_info[0] == 2:  # Python 2
        from urllib2 import Request, urlopen

    # Supply a user-agent header of a common browser, since some web servers will refuse to reply to scripts without one.
    requestObj = Request(url, headers={'User-agent' : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:97.0) Gecko/20100101 Firefox/97.0'})
    responseObj = urlopen(requestObj)

    return responseObj.read()








